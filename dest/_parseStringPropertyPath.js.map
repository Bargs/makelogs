{"version":3,"sources":["../src/_parseStringPropertyPath.js"],"names":["module","exports","parseStringPropertyPath","propertyPath","character","parsedPropertyPath","parsedPropertyPathPart","escapeNextCharacter","isSpecialCharacter","insideBrackets","i","length","SyntaxError","push","TypeError","splice"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;AAKAA,OAAOC,OAAP,GAAiB,SAASC,uBAAT,CAAiCC,YAAjC,EAA+C;AAC9D,MAAIC,YAAY,EAAhB;AACA,MAAMC,qBAAqB,EAA3B;AACA,MAAIC,yBAAyB,EAA7B;AACA,MAAIC,sBAAsB,KAA1B;AACA,MAAIC,qBAAqB,KAAzB;AACA,MAAIC,iBAAiB,KAArB;;AAEA;AACA;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIP,aAAaQ,MAAjC,EAAyCD,KAAK,CAA9C,EAAiD;AAC/CN,gBAAYD,aAAaO,CAAb,CAAZ;AACAF,yBAAsBJ,cAAc,IAAd,IAAsBA,cAAc,GAApC,IAA2CA,cAAc,GAAzD,IAAgEA,cAAc,GAApG;;AAEA,QAAII,sBAAsB,CAACD,mBAA3B,EAAgD;AAC9C,UAAIE,kBAAkBL,cAAc,GAApC,EAAyC;AACvC,cAAM,IAAIQ,WAAJ,kBACWR,SADX,uCAEJM,CAFI,0BAEkBP,YAFlB,CAAN;AAID;;AAED,cAAQC,SAAR;AACE,aAAK,IAAL;AACEG,gCAAsB,IAAtB;AACA;AACF,aAAK,GAAL;AACEE,2BAAiB,KAAjB;AACA;AACF,aAAK,GAAL;AACEA,2BAAiB,IAAjB;AACA;AACF,aAAK,GAAL;AACEJ,6BAAmBQ,IAAnB,CAAwBP,sBAAxB;AACAA,mCAAyB,EAAzB;AACA;;AAEF;AACE,gBAAM,IAAIQ,SAAJ,4BAAuCV,SAAvC,oBAAN;AAhBJ;AAkBD,KA1BD,MA0BO;AACLE,gCAA0BF,SAA1B;AACAG,4BAAsB,KAAtB;AACD;AACF;;AAED,MAAIF,mBAAmB,CAAnB,MAA0B,EAA9B,EAAkC;AAChC;AACAA,uBAAmBU,MAAnB,CAA0B,CAA1B,EAA6B,CAA7B;AACD;;AAED;AACAV,qBAAmBQ,IAAnB,CAAwBP,sBAAxB;AACA,SAAOD,kBAAP;AACD,CAtDD","file":"_parseStringPropertyPath.js","sourcesContent":["//\n// From lodash-deep\n//\n// https://github.com/marklagendijk/lodash-deep/blob/master/lodash-deep.js#L419-L474\n//\n/**\n * Parses a string based propertyPath\n * @param {string} propertyPath\n * @returns {Array}\n */\nmodule.exports = function parseStringPropertyPath(propertyPath) {\n  let character = ''\n  const parsedPropertyPath = []\n  let parsedPropertyPathPart = ''\n  let escapeNextCharacter = false\n  let isSpecialCharacter = false\n  let insideBrackets = false\n\n  // Walk through the path and find backslashes that escape periods or other backslashes, and split on unescaped\n  // periods and brackets.\n  for (let i = 0; i < propertyPath.length; i += 1) {\n    character = propertyPath[i]\n    isSpecialCharacter = (character === '\\\\' || character === '[' || character === ']' || character === '.')\n\n    if (isSpecialCharacter && !escapeNextCharacter) {\n      if (insideBrackets && character !== ']') {\n        throw new SyntaxError(\n          `unexpected \"${character}\" within brackets at character ${\n          i} in property path ${propertyPath}`\n        )\n      }\n\n      switch (character) {\n        case '\\\\':\n          escapeNextCharacter = true\n          break\n        case ']':\n          insideBrackets = false\n          break\n        case '[':\n          insideBrackets = true\n          /* falls through */\n        case '.':\n          parsedPropertyPath.push(parsedPropertyPathPart)\n          parsedPropertyPathPart = ''\n          break\n\n        default:\n          throw new TypeError(`unexpected character \"${character}\" in omit path`)\n      }\n    } else {\n      parsedPropertyPathPart += character\n      escapeNextCharacter = false\n    }\n  }\n\n  if (parsedPropertyPath[0] === '') {\n    // allow '[0]', or '.0'\n    parsedPropertyPath.splice(0, 1)\n  }\n\n  // capture the final part\n  parsedPropertyPath.push(parsedPropertyPathPart)\n  return parsedPropertyPath\n}\n"]}