{"version":3,"sources":["../../src/eventBuffer/_bulkQueue.js"],"names":["async","require","attempt","_","argv","first","module","exports","queue","events","done","body","esBulkQueueOverflow","startedIndexing","forEach","push","index","event","header","length","log","bulk","then","eventCount","resp","items","errors","item","i","error","create","isPlainObject","reason","match","eventBuffer","console","process","exit","progress","catch","err","stack","finally","pause","setTimeout","resume","nodeify","drain","final","close","doneIndexing","flush"],"mappings":";;AAAA;;AAEA,IAAMA,QAAQC,QAAQ,OAAR,CAAd;;eACoBA,QAAQ,UAAR,C;IAAZC,O,YAAAA,O;;AACR,IAAMC,IAAIF,QAAQ,QAAR,CAAV;;AAEA,IAAMG,OAAOH,QAAQ,SAAR,CAAb;;AAEA,IAAII,QAAQ,IAAZ;;AAEAC,OAAOC,OAAP,GAAiB,uBAAe;AAC9B,MAAMC,QAAQR,MAAMQ,KAAN,CAAY,UAACC,MAAD,EAASC,IAAT,EAAkB;AAC1C,QAAMC,OAAO,EAAb;AACA,QAAIC,sBAAsB,CAA1B;;AAEA,QAAIP,KAAJ,EAAW;AACTD,WAAKS,eAAL;AACAR,cAAQ,KAAR;AACD;;AAEDI,WAAOK,OAAP,CAAe,iBAAS;AACtBH,WAAKI,IAAL,CAAU,EAAEC,OAAOC,MAAMC,MAAf,EAAV,EAAmCD,MAAMN,IAAzC;AACD,KAFD;;AAIAT,YAAQ,YAAM;AACZ,UAAIS,KAAKQ,MAAT,EAAiB;AACff,aAAKgB,GAAL,CAAS,SAAT,EAAoBT,KAAKQ,MAAL,GAAc,CAAlC,EAAqC,eAArC;AACA,eAAO,eAAOE,IAAP,CAAY,EAAEV,UAAF,EAAZ,CAAP;AACD;;AAED,aAAO,EAAP;AACD,KAPD,EAQCW,IARD,CAQM,gBAAQ;AACZ,UAAIC,aAAaC,KAAKC,KAAL,CAAWN,MAA5B;AACA,UAAIK,KAAKE,MAAT,EAAiB;AACfF,aAAKC,KAAL,CAAWX,OAAX,CAAmB,UAACa,IAAD,EAAOC,CAAP,EAAa;AAC9B,cAAIC,QAAQ,CAACF,KAAKX,KAAL,IAAcW,KAAKG,MAApB,EAA4BD,KAAxC;AACA,cAAI1B,EAAE4B,aAAF,CAAgBF,KAAhB,KAA0BA,MAAMG,MAApC,EAA4C;AAC1CH,oBAAQA,MAAMG,MAAd;AACD;AACD,cAAIH,KAAJ,EAAW;AACTN,0BAAc,CAAd;;AAEA,gBAAIM,MAAMI,KAAN,CAAY,+BAAZ,CAAJ,EAAkD;AAChDrB,qCAAuB,CAAvB;AACAsB,0BAAYnB,IAAZ,CAAiBN,OAAOmB,CAAP,CAAjB;AACD,aAHD,MAGO;AACLO,sBAAQN,KAAR,CAAcA,KAAd;AACAO,sBAAQC,IAAR;AACD;AACF;AACF,SAhBD;AAiBD;;AAEDjC,WAAKkC,QAAL,CAAcf,UAAd;AACD,KA/BD,EAgCCgB,KAhCD,CAgCO,eAAO;AACZJ,cAAQN,KAAR,CAAcW,IAAIC,KAAlB;AACA,YAAMD,GAAN;AACD,KAnCD,EAoCCE,OApCD,CAoCS,YAAM;AACb,UAAI9B,mBAAJ,EAAyB;AACvB;AACAJ,cAAMmC,KAAN;AACAC,mBAAW,YAAM;AACfpC,gBAAMqC,MAAN;AACD,SAFD,EAEG,KAAKjC,mBAFR;AAGD;AACF,KA5CD,EA6CCkC,OA7CD,CA6CSpC,IA7CT;AA8CD,GA3Da,EA2DX,CA3DW,CAAd;;AA6DAF,QAAMuC,KAAN,GAAc,YAAM;AAClB,QAAIb,YAAYc,KAAZ,IAAqBd,YAAYf,MAAZ,KAAuB,CAAhD,EAAmD;AACjD,qBAAO8B,KAAP;AACA7C,WAAK8C,YAAL;AACD,KAHD,MAGO;AACLhB,kBAAYiB,KAAZ;AACD;AACF,GAPD;;AASA,SAAO3C,KAAP;AACD,CAxED","file":"_bulkQueue.js","sourcesContent":["import { client } from '../client'\n\nconst async = require('async')\nconst { attempt } = require('bluebird')\nconst _ = require('lodash')\n\nconst argv = require('../argv')\n\nlet first = true\n\nmodule.exports = eventBuffer => {\n  const queue = async.queue((events, done) => {\n    const body = []\n    let esBulkQueueOverflow = 0\n\n    if (first) {\n      argv.startedIndexing()\n      first = false\n    }\n\n    events.forEach(event => {\n      body.push({ index: event.header }, event.body)\n    })\n\n    attempt(() => {\n      if (body.length) {\n        argv.log('sending', body.length / 2, 'bulk requests')\n        return client.bulk({ body })\n      }\n\n      return {}\n    })\n    .then(resp => {\n      let eventCount = resp.items.length\n      if (resp.errors) {\n        resp.items.forEach((item, i) => {\n          let error = (item.index || item.create).error\n          if (_.isPlainObject(error) && error.reason) {\n            error = error.reason\n          }\n          if (error) {\n            eventCount -= 1\n\n            if (error.match(/^EsRejectedExecutionException/)) {\n              esBulkQueueOverflow += 1\n              eventBuffer.push(events[i])\n            } else {\n              console.error(error)\n              process.exit()\n            }\n          }\n        })\n      }\n\n      argv.progress(eventCount)\n    })\n    .catch(err => {\n      console.error(err.stack)\n      throw err\n    })\n    .finally(() => {\n      if (esBulkQueueOverflow) {\n        // pause for 10ms per queue overage\n        queue.pause()\n        setTimeout(() => {\n          queue.resume()\n        }, 10 * esBulkQueueOverflow)\n      }\n    })\n    .nodeify(done)\n  }, 1)\n\n  queue.drain = () => {\n    if (eventBuffer.final && eventBuffer.length === 0) {\n      client.close()\n      argv.doneIndexing()\n    } else {\n      eventBuffer.flush()\n    }\n  }\n\n  return queue\n}\n"]}