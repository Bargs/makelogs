{"version":3,"sources":["../src/_omitFields.js"],"names":["_","require","argv","parseStringPropertyPath","module","exports","omit","identity","rawPaths","isArray","paths","map","body","isFieldMap","walkIn","unDefine","obj","path","step","shift","next","length","undefined","properties","unshift","arr","forEach"],"mappings":";;AAAA,IAAMA,IAAIC,QAAQ,QAAR,CAAV;AACA,IAAMC,OAAOD,QAAQ,QAAR,CAAb;;AAEA,IAAME,0BAA0BF,QAAQ,4BAAR,CAAhC;;AAEAG,OAAOC,OAAP,GAAiB,CAACH,KAAKI,IAAN,GACfN,EAAEO,QADa,GAEd,YAAM;AACP,MAAMC,WACJR,EAAES,OAAF,CAAUP,KAAKI,IAAf,IACEJ,KAAKI,IADP,GAEE,CAAEJ,KAAKI,IAAP,CAHJ;AAKA,MAAMI,QAAQF,SAASG,GAAT,CAAaR,uBAAb,CAAd;;AAEA,SAAO,UAACS,IAAD,EAAOC,UAAP,EAAsB;AAC3B,QAAIC,eAAJ;AACA,QAAMC,WAAW,SAAXA,QAAW,CAACC,GAAD,EAAMC,IAAN,EAAe;AAC9B,UAAI,CAACD,GAAL,EAAU;;AAEV,UAAME,OAAOD,KAAKE,KAAL,EAAb;AACA,UAAIC,OAAOJ,IAAIE,IAAJ,CAAX;;AAEA,UAAID,KAAKI,MAAL,KAAgB,CAApB,EAAuB;AACrB;AACAL,YAAIE,IAAJ,IAAYE,OAAOE,SAAnB;AACD,OAHD,MAGO,IAAIF,QAAQF,SAAS,IAArB,EAA2B;AAChCJ,eAAOM,IAAP,EAAaH,IAAb;AACD,OAFM,MAEA,IAAIG,IAAJ,EAAU;AACf;AACA,YAAIP,UAAJ,EAAgB;AACdE,mBAASK,KAAKG,UAAd,EAA0BN,IAA1B;AACD,SAFD,MAEO;AACLF,mBAASK,IAAT,EAAeH,IAAf;AACD;AACF;;AAEDA,WAAKO,OAAL,CAAaN,IAAb;AACD,KArBD;;AAuBAJ,aAAS,gBAACW,GAAD,EAAMR,IAAN,EAAe;AACtB,UAAI,CAACjB,EAAES,OAAF,CAAUgB,GAAV,CAAL,EAAqB;;AAErBA,UAAIC,OAAJ,CAAY,eAAO;AACjBX,iBAASC,GAAT,EAAcC,IAAd;AACD,OAFD;AAGD,KAND;;AAQAJ,iBAAa,CAAC,CAACA,UAAf;AACAH,UAAMgB,OAAN,CAAc,gBAAQ;AACpBX,eAASH,IAAT,EAAeK,IAAf;AACD,KAFD;;AAIA,WAAOL,IAAP;AACD,GAvCD;AAwCD,CAhDC,EAFF","file":"_omitFields.js","sourcesContent":["const _ = require('lodash')\nconst argv = require('./argv')\n\nconst parseStringPropertyPath = require('./_parseStringPropertyPath')\n\nmodule.exports = !argv.omit\n? _.identity\n: (() => {\n  const rawPaths = (\n    _.isArray(argv.omit)\n    ? argv.omit\n    : [ argv.omit ]\n  )\n  const paths = rawPaths.map(parseStringPropertyPath)\n\n  return (body, isFieldMap) => {\n    let walkIn\n    const unDefine = (obj, path) => {\n      if (!obj) return\n\n      const step = path.shift()\n      let next = obj[step]\n\n      if (path.length === 0) {\n        // end of the line\n        obj[step] = next = undefined\n      } else if (next && step === '[]') {\n        walkIn(next, path)\n      } else if (next) {\n        // FIXME Make this prettier\n        if (isFieldMap) {\n          unDefine(next.properties, path)\n        } else {\n          unDefine(next, path)\n        }\n      }\n\n      path.unshift(step)\n    }\n\n    walkIn = (arr, path) => {\n      if (!_.isArray(arr)) return\n\n      arr.forEach(obj => {\n        unDefine(obj, path)\n      })\n    }\n\n    isFieldMap = !!isFieldMap\n    paths.forEach(path => {\n      unDefine(body, path)\n    })\n\n    return body\n  }\n})()\n"]}